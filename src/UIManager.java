import processing.core.PApplet;

import java.awt.*;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.Collections;

public class UIManager {
	// View
	protected boolean redrawRequested, redrawWidgetsRequested;
	protected int canvasWidth, canvasHeight;
	protected int windowWidth, windowHeight;
	protected int widgetsSize;

	// Model
	protected Entry content;

	// widgets
	protected java.util.List<Widget> widgets = new ArrayList<>();
	protected int lastX = 0, lastY = 0;

	public PApplet applet;

	public UIManager(PApplet applet) {
		this.applet = applet;
	}

	public void setContent(Entry content) {
		this.content = content;
	}

	// interfaces

	/**
	 * Delegate of setup() in {@link PApplet}
	 */
	public void onSetup() {
		this.applet.smooth();
		if (this.content != null) this.content.setup();
		this.redrawRequested = true;
	}

	/**
	 * Delegate of draw() in {@link PApplet}
	 */
	public void onDraw() {
		if (this.redrawRequested) {
			// entries may want to clear the applet, so widgets also have to be redrawn
			if (this.content != null) this.content.draw();
			this.drawWidgets();
			this.redrawRequested = false;
			this.redrawWidgetsRequested = false;
		} else if (this.redrawWidgetsRequested) {
			this.drawWidgets();
			this.redrawWidgetsRequested = false;
		}
	}

	// public methods
	public void setCanvasSize(int width, int height) {
		this.updateWidgetsLayout(width, height);

		this.canvasWidth = width;
		this.canvasHeight = height;
		this.windowWidth = width;
		this.windowHeight = height + this.widgetsSize;
		// applet.getSurface().setSize() has few limitations, comparing to PApplet.size()
		this.applet.getSurface().setSize(this.windowWidth, this.windowHeight);

		// place window in center of the screen
		Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
		this.applet.getSurface().setLocation((screenSize.width - this.windowWidth) / 2,
				(screenSize.height - this.windowHeight) / 2);
	}

	public void requestRedraw() {
		this.redrawRequested = true;
	}

	public void requestRedrawWidgets() {
		this.redrawWidgetsRequested = true;
	}

	/**
	 * Add checkbox widget.
	 *
	 * @param label
	 * 		checkbox label
	 * @param listener
	 * 		checkbox event listener
	 * @param initial
	 * 		initial value
	 *
	 * @return the checkbox widget
	 */
	public Widget addCheck(String label, CheckListener listener, boolean initial) {
		Widget widget = new CheckWidget(this, label, listener, initial);
		this.widgets.add(widget);
		this.requestRedrawWidgets();
		return widget;
	}

	/**
	 * Add radio widget.
	 *
	 * @param labels
	 * 		radio labels
	 * @param listener
	 * 		radio event listener
	 * @param initial
	 * 		initial choice
	 *
	 * @return the radio widget
	 */
	public Widget addRadio(String[] labels, RadioListener listener, int initial) {
		Widget widget = new RadioWidget(this, labels, listener, initial);
		this.widgets.add(widget);
		this.requestRedrawWidgets();
		return widget;
	}

	/**
	 * Update the widget layouts.<br />
	 * The layout of widgets follow a very simple rule:<br />
	 * One widget follows another, and wraps to another line, when and only when, its
	 * width exceeds the left space from the right border of the last widget and the
	 * right border of the canvas ( minus padding ).<br />
	 * Since window sizes are yet not set before this method returns, required width and
	 * height of the canvas are given as parameters.
	 *
	 * @param canvasWidth
	 * 		width of canvas
	 * @param canvasHeight
	 * 		height of canvas
	 */
	private void updateWidgetsLayout(int canvasWidth, int canvasHeight) {
		if (this.widgets.isEmpty()) {
			this.widgetsSize = 0;
			return;
		}

		int padding = 10, spacing = 10;
		int x = padding, y = canvasHeight + padding;

		int maxHeight = 0;    // max height of widgets in this line
		for (Widget widget : this.widgets) {
			Dimension size = widget.getSize();

			maxHeight = Math.max(maxHeight, size.height);
			// wrap line when needed
			if (size.width + x + padding > canvasWidth) {
				x = padding;
				y += maxHeight + spacing;
				maxHeight = 0;
			}

			Point p = new Point(x, y);
			widget.setLocation(p);

			// increase x
			x += size.width + spacing;
		}

		this.widgetsSize = y + maxHeight + padding - canvasHeight;
	}

	private void drawWidgets() {
		// draw widgets panel background
		this.applet.fill(255);
		this.applet.noStroke();
		this.applet.rect(0, this.canvasHeight, this.canvasWidth,
				this.windowHeight - this.canvasHeight);

		this.widgets.forEach(Widget::draw);
	}

	/**
	 * pointer listener areas generated by widgets
	 */
	protected java.util.List<PointerArea> areas = new ArrayList<>();

	/**
	 * Listen a new {@link PointerArea}
	 */
	public PointerArea listen(Rectangle rectangle, MouseListener listener) {
		PointerArea area = new PointerArea(rectangle, listener);
		this.areas.add(area);
		return area;
	}

	public void onMouseMoved() {
		int x = this.applet.mouseX, y = this.applet.mouseY;
		for (PointerArea area : this.areas) area.mouseMove(this.lastX, this.lastY, x, y);
		this.lastX = x;
		this.lastY = y;
	}

	public void onMouseDown() {
		int button = Mouse.translate(this.applet.mouseButton);
		for (PointerArea area : this.areas)
			area.mouseDown(this.applet.mouseX, this.applet.mouseY, button);
	}

	public void onMouseUp() {
		int button = Mouse.translate(this.applet.mouseButton);
		for (PointerArea area : this.areas)
			area.mouseUp(this.applet.mouseX, this.applet.mouseY, button);
	}

	private static class PointerArea {
		public Rectangle range;
		public java.util.List<MouseListener> listeners = new ArrayList<>();

		public PointerArea(Rectangle range) {
			this.range = new Rectangle(range);
		}

		public PointerArea(Rectangle range, MouseListener... listeners) {
			this(range);
			Collections.addAll(this.listeners, listeners);
		}

		public void mouseMove(int lastX, int lastY, int x, int y) {
			boolean lastIn = this.range.contains(lastX, lastY);
			boolean thisIn = this.range.contains(x, y);
			if (lastIn && !thisIn)
				for (MouseListener listener : this.listeners)
					listener.mouseExited(this.createMouseEvent(x, y));
			if (thisIn && !lastIn)
				for (MouseListener listener : this.listeners)
					listener.mouseEntered(this.createMouseEvent(x, y));
		}

		public void mouseDown(int x, int y, int button) {
			if (this.range.contains(x, y))
				for (MouseListener listener : this.listeners)
					listener.mousePressed(this.createMouseEvent(x, y, button));
		}

		public void mouseUp(int x, int y, int button) {
			if (this.range.contains(x, y))
				for (MouseListener listener : this.listeners)
					listener.mouseReleased(this.createMouseEvent(x, y, button));
		}

		private final Component PLACEHOLDER_COMPONENT = new Frame();

		private java.awt.event.MouseEvent createMouseEvent(int x, int y) {
			return new java.awt.event.MouseEvent(this.PLACEHOLDER_COMPONENT,
					0, 0L, 0, x, y, 0, false);
		}

		private java.awt.event.MouseEvent createMouseEvent(int x, int y, int button) {
			return new java.awt.event.MouseEvent(this.PLACEHOLDER_COMPONENT,
					0, 0L, 0, x, y, 0, false, button);
		}
	}
}